<!DOCTYPE html>
<html>
  <head>
    <title>fabricjs自定义圆角矩形元素（修正版）</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <style>
      canvas {
        border: 1px solid #ccc;
      }
    </style>
  </head>
  <body>
    <div id="canvas-container">
      <canvas id="canvas" width="800" height="800"></canvas>
    </div>

    <script>
      const CustomRect = fabric.util.createClass(fabric.Rect, {
        type: "custom-rect",

        initialize: function (options) {
          options || (options = {});
          this.callSuper("initialize", options);

          if (options.maxRadius) {
            this.maxRadius = true;
            this.width = Math.max(this.width, 5);
            this.height = Math.max(this.height, 5);
            const r = Math.min(this.width, this.height) / 2 + 10;
            this.radius = [
              [r, r],
              [r, r],
              [r, r],
              [r, r],
            ];
          } else {
            this.maxRadius = false;
            this._parseRadius(options.radius || 0);
          }

          this.set({
            lockScalingX: true,
            lockScalingY: true,
            objectCaching: false,
          });

          this._initCustomControls();
        },

        _parseRadius: function (radius) {
          let r = [];

          if (typeof radius === "number") {
            r = [
              [radius, radius],
              [radius, radius],
              [radius, radius],
              [radius, radius],
            ];
          } else if (Array.isArray(radius)) {
            if (radius.length === 2) {
              r = [
                [radius[0], radius[0]],
                [radius[1], radius[1]],
                [radius[0], radius[0]],
                [radius[1], radius[1]],
              ];
            } else if (radius.length === 3) {
              r = [
                [radius[0], radius[0]],
                [radius[1], radius[1]],
                [radius[2], radius[2]],
                [radius[1], radius[1]],
              ];
            } else if (radius.length === 4) {
              r = [
                [radius[0], radius[0]],
                [radius[1], radius[1]],
                [radius[2], radius[2]],
                [radius[3], radius[3]],
              ];
            } else if (Array.isArray(radius[0])) {
              r = radius;
            }
          }

          if (!r.length) {
            r = [
              [0, 0],
              [0, 0],
              [0, 0],
              [0, 0],
            ];
          }

          this.radius = r;
        },

        _render: function (ctx) {
          const w = Math.max(this.width, 5);
          const h = Math.max(this.height, 5);
          const x = -w / 2,
            y = -h / 2;

          ctx.beginPath();

          if (this.maxRadius) {
            const r = h / 2;
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
            ctx.closePath();
          } else {
            const [tl, tr, br, bl] = this.radius;
            ctx.moveTo(x + tl[0], y);
            ctx.lineTo(x + w - tr[0], y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + tr[1]);
            ctx.lineTo(x + w, y + h - br[1]);
            ctx.quadraticCurveTo(x + w, y + h, x + w - br[0], y + h);
            ctx.lineTo(x + bl[0], y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - bl[1]);
            ctx.lineTo(x, y + tl[1]);
            ctx.quadraticCurveTo(x, y, x + tl[0], y);
            ctx.closePath();
          }

          this._renderFill(ctx);
          this._renderStroke(ctx);
        },

        _initCustomControls: function () {
          // 右下角
          this.controls.br = new fabric.Control({
            x: 0.5,
            y: 0.5,
            cursorStyle: "nwse-resize",
            actionHandler: (eventData, transform, x, y) => {
              const target = transform.target;
              const canvas = target.canvas;
              const local = target.toLocalPoint(
                new fabric.Point(x, y),
                "center",
                "center"
              );

              let newW = local.x + target.width / 2;
              let newH = local.y + target.height / 2;

              newW = Math.max(1, newW);
              newH = Math.max(1, newH);

              if (target.maxRadius) {
                let radius = newH / 2;
                newH = Math.max(newH, 5);
                radius = newH / 2;
                newW = Math.max(newW, radius * 2);
                target.radius = [
                  [radius, radius],
                  [radius, radius],
                  [radius, radius],
                  [radius, radius],
                ];
              }

              target.set({ width: newW, height: newH, scaleX: 1, scaleY: 1 });
              target.setCoords();
              canvas.requestRenderAll();
              return true;
            },
          });

          // 右边
          this.controls.mr = new fabric.Control({
            x: 0.5,
            y: 0,
            cursorStyle: "ew-resize",
            actionHandler: (eventData, transform, x, y) => {
              const target = transform.target;
              const canvas = target.canvas;
              const local = target.toLocalPoint(
                new fabric.Point(x, y),
                "center",
                "center"
              );

              let newW = local.x + target.width / 2;
              newW = Math.max(1, newW);
              target.set({ width: newW, scaleX: 1 });
              target.setCoords();
              canvas.requestRenderAll();
              return true;
            },
          });

          // ✅ 左边（已修正）
          this.controls.ml = new fabric.Control({
            x: -0.5,
            y: 0,
            cursorStyle: "ew-resize",
            actionHandler: (eventData, transform, x, y) => {
              const target = transform.target;
              const canvas = target.canvas;
              const local = target.toLocalPoint(
                new fabric.Point(x, y),
                "center",
                "center"
              );

              let newW = target.width / 2 - local.x;
              newW = Math.max(1, newW);

              const deltaW = newW - target.width;
              target.set({
                width: newW,
                left: target.left - deltaW, // ✅ 固定左边不动
                scaleX: 1,
              });

              target.setCoords();
              canvas.requestRenderAll();
              return true;
            },
          });

          // ✅ 上边（已修正）
          this.controls.mt = new fabric.Control({
            x: 0,
            y: -0.5,
            cursorStyle: "ns-resize",
            actionHandler: (eventData, transform, x, y) => {
              const target = transform.target;
              const canvas = target.canvas;
              const local = target.toLocalPoint(
                new fabric.Point(x, y),
                "center",
                "center"
              );

              let newH = target.height / 2 - local.y;
              newH = Math.max(1, newH);

              const deltaH = newH - target.height;
              target.set({
                height: newH,
                top: target.top - deltaH, // ✅ 固定上边不动
                scaleY: 1,
              });

              target.setCoords();
              canvas.requestRenderAll();
              return true;
            },
          });

          // 下边
          this.controls.mb = new fabric.Control({
            x: 0,
            y: 0.5,
            cursorStyle: "ns-resize",
            actionHandler: (eventData, transform, x, y) => {
              const target = transform.target;
              const canvas = target.canvas;
              const local = target.toLocalPoint(
                new fabric.Point(x, y),
                "center",
                "center"
              );

              let newH = local.y + target.height / 2;
              newH = Math.max(1, newH);
              target.set({ height: newH, scaleY: 1 });
              target.setCoords();
              canvas.requestRenderAll();
              return true;
            },
          });
        },
      });

      fabric.CustomRect = CustomRect;
      fabric.CustomRect.fromObject = (options, callback) => {
        const { radius } = options;
        return callback(new fabric.CustomRect(radius, options));
      };

      const canvas = new fabric.Canvas("canvas", { width: 800, height: 800 });

      const rect = new fabric.CustomRect({
        left: 20,
        top: 20,
        width: 100,
        height: 50,
        fill: "lightblue",
        stroke: "black",
        strokeWidth: 1,
        radius: [0, 5, 10, 15],
      });
      canvas.add(rect);

      const rect2 = new fabric.CustomRect({
        left: 150,
        top: 20,
        width: 150,
        height: 50,
        fill: "lightgreen",
        stroke: "black",
        strokeWidth: 1,
        radius: [0, 0, 10, 10],
      });
      canvas.add(rect2);

      const rect3 = new fabric.CustomRect({
        left: 320,
        top: 20,
        width: 50,
        height: 150,
        fill: "lightgreen",
        stroke: "black",
        strokeWidth: 1,
        radius: [10, 0, 0, 10],
      });
      canvas.add(rect3);

      const rect4 = new fabric.CustomRect({
        left: 20,
        top: 120,
        width: 200,
        height: 80,
        fill: "lightgreen",
        stroke: "black",
        strokeWidth: 1,
        maxRadius: true,
      });
      canvas.add(rect4);
    </script>
  </body>
</html>
