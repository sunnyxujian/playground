<!DOCTYPE html>
<!--
  æœ¬é¡µé¢å®Œå…¨ä½¿ç”¨æœ¬åœ°èµ„æºï¼Œä¸ä¾èµ–ä»»ä½•CDNã€‚
  ä½¿ç”¨ Tesseract.js 7.x ç‰ˆæœ¬ã€‚
  è¯·ç¡®ä¿ä»¥ä¸‹æ–‡ä»¶å­˜åœ¨ï¼š
  - js/tesseract/tesseract.min.js (7.xç‰ˆæœ¬)
  - js/tesseract/worker.min.js (7.xç‰ˆæœ¬)
  - js/tesseract/4.0.0/chi_sim.traineddata.gz
  æˆ–
  - js/tesseract/chi_sim.traineddata.gz
-->
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>OCRè¯†åˆ« - æ£€æµ‹"ç”µç½‘"æ–‡æ¡ˆï¼ˆæœ¬åœ°ç‰ˆï¼‰</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
          "Microsoft YaHei", sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
      }

      .container {
        max-width: 900px;
        margin: 0 auto;
        background: white;
        border-radius: 16px;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
        padding: 40px;
      }

      h1 {
        text-align: center;
        color: #333;
        margin-bottom: 30px;
        font-size: 28px;
      }

      .upload-area {
        border: 3px dashed #667eea;
        border-radius: 12px;
        padding: 40px;
        text-align: center;
        background: #f8f9ff;
        cursor: pointer;
        transition: all 0.3s ease;
        margin-bottom: 30px;
      }

      .upload-area:hover {
        border-color: #764ba2;
        background: #f0f2ff;
      }

      .upload-area.dragover {
        border-color: #764ba2;
        background: #e8ebff;
        transform: scale(1.02);
      }

      #fileInput {
        display: none;
      }

      .upload-icon {
        font-size: 48px;
        margin-bottom: 15px;
      }

      .upload-text {
        color: #666;
        font-size: 16px;
        margin-bottom: 10px;
      }

      .upload-hint {
        color: #999;
        font-size: 14px;
      }

      .preview-section {
        margin-bottom: 30px;
      }

      .preview-image {
        max-width: 100%;
        max-height: 400px;
        border-radius: 8px;
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        display: block;
        margin: 20px auto;
      }

      .button-group {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
      }

      .button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 14px 32px;
        border-radius: 8px;
        font-size: 16px;
        cursor: pointer;
        transition: all 0.3s ease;
        font-weight: 600;
        flex: 1;
      }

      .button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 20px rgba(102, 126, 234, 0.4);
      }

      .button:disabled {
        opacity: 0.6;
        cursor: not-allowed;
        transform: none;
      }

      .button-clear {
        background: #6c757d;
        flex: 0 0 auto;
        padding: 14px 24px;
      }

      .button-clear:hover {
        background: #5a6268;
        box-shadow: 0 8px 20px rgba(108, 117, 125, 0.4);
      }

      .progress-section {
        margin-bottom: 30px;
      }

      .progress-bar {
        width: 100%;
        height: 8px;
        background: #e0e0e0;
        border-radius: 4px;
        overflow: hidden;
        margin-bottom: 10px;
      }

      .progress-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
        width: 0%;
        transition: width 0.3s ease;
      }

      .progress-text {
        text-align: center;
        color: #666;
        font-size: 14px;
      }

      .result-section {
        background: #f8f9ff;
        border-radius: 8px;
        padding: 20px;
        margin-top: 20px;
      }

      .result-title {
        font-size: 18px;
        font-weight: 600;
        color: #333;
        margin-bottom: 15px;
      }

      .result-content {
        background: white;
        padding: 15px;
        border-radius: 6px;
        border-left: 4px solid #667eea;
        margin-bottom: 15px;
      }

      .result-text {
        color: #333;
        line-height: 1.6;
        white-space: pre-wrap;
        word-break: break-all;
      }

      .result-text mark {
        font-weight: 600;
      }

      .detection-result {
        padding: 15px;
        border-radius: 6px;
        font-weight: 600;
        text-align: center;
        font-size: 18px;
      }

      .detection-result.found {
        background: #d4edda;
        color: #155724;
        border: 2px solid #c3e6cb;
      }

      .detection-result.not-found {
        background: #f8d7da;
        color: #721c24;
        border: 2px solid #f5c6cb;
      }

      .hidden {
        display: none;
      }

      .status-info {
        background: #e7f3ff;
        border-left: 4px solid #2196f3;
        padding: 12px 15px;
        border-radius: 6px;
        margin-bottom: 20px;
        font-size: 14px;
        color: #1976d2;
      }

      .status-info.loading {
        background: #fff3cd;
        border-left-color: #ffc107;
        color: #856404;
      }

      .status-info.error {
        background: #f8d7da;
        border-left-color: #dc3545;
        color: #721c24;
      }

      .loading {
        display: inline-block;
        width: 20px;
        height: 20px;
        border: 3px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 1s ease-in-out infinite;
        margin-right: 10px;
        vertical-align: middle;
      }

      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <h1>ğŸ” OCRè¯†åˆ« - æ£€æµ‹"ç”µç½‘"æ–‡æ¡ˆï¼ˆTesseract.js 7.0.0 æœ¬åœ°ç‰ˆ - ä¼˜åŒ–ç‰ˆï¼‰</h1>

      <div class="status-info" id="statusInfo">
        <span id="statusText">æ­£åœ¨åŠ è½½OCRåº“ï¼Œè¯·ç¨å€™...</span>
      </div>

      <div style="background: #fff9e6; padding: 12px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #ff9800; font-size: 13px; color: #856404;">
        <strong>ğŸ’¡ æå‡è¯†åˆ«ç‡çš„å»ºè®®ï¼š</strong>
        <ul style="margin: 8px 0 0 20px; padding: 0;">
          <li><strong>é¢„å¤„ç†æ¨¡å¼é€‰æ‹©ï¼š</strong>
            <ul style="margin: 4px 0 0 20px; padding: 0;">
              <li><strong>å¢å¼ºæ¨¡å¼</strong>ï¼šé€‚åˆå¤§å¤šæ•°æƒ…å†µï¼Œè‡ªåŠ¨å¢å¼ºå¯¹æ¯”åº¦å’Œé”åŒ–</li>
              <li><strong>äºŒå€¼åŒ–æ¨¡å¼</strong>ï¼šé€‚åˆæ¸…æ™°çš„é»‘ç™½æ–‡å­—å›¾ç‰‡</li>
              <li><strong>æ¿€è¿›æ¨¡å¼</strong>ï¼šé€‚åˆæ¨¡ç³Šã€ä½å¯¹æ¯”åº¦çš„å›¾ç‰‡</li>
            </ul>
          </li>
          <li>ä½¿ç”¨æ¸…æ™°ã€é«˜åˆ†è¾¨ç‡çš„å›¾ç‰‡ï¼ˆç³»ç»Ÿä¼šè‡ªåŠ¨ä¼˜åŒ–åˆ°300DPIï¼‰</li>
          <li>æ ¹æ®å›¾ç‰‡å†…å®¹é€‰æ‹©åˆé€‚çš„PSMæ¨¡å¼ï¼ˆå•è¡Œç”¨7ï¼Œå¤šè¡Œç”¨6æˆ–13ï¼‰</li>
          <li>å¦‚æœè¯†åˆ«ç‡ä½ï¼Œå°è¯•åˆ‡æ¢ä¸åŒçš„é¢„å¤„ç†æ¨¡å¼å’ŒPSMæ¨¡å¼</li>
          <li>å¯¹äºæ¨¡ç³Šå›¾ç‰‡ï¼Œä½¿ç”¨"æ¿€è¿›æ¨¡å¼"é¢„å¤„ç†</li>
        </ul>
      </div>

      <div class="upload-area" id="uploadArea">
        <div class="upload-icon">ğŸ“</div>
        <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½å›¾ç‰‡åˆ°æ­¤å¤„</div>
        <div class="upload-hint">æ”¯æŒ JPGã€PNG ç­‰å¸¸è§å›¾ç‰‡æ ¼å¼</div>
        <input type="file" id="fileInput" accept="image/*" />
      </div>

      <div class="preview-section hidden" id="previewSection">
        <img id="previewImage" class="preview-image" alt="é¢„è§ˆå›¾ç‰‡" />
      </div>

      <div style="background: #f0f7ff; padding: 15px; border-radius: 8px; margin-bottom: 20px; border-left: 4px solid #2196f3;">
        <div style="font-weight: 600; color: #1976d2; margin-bottom: 12px;">
          âš™ï¸ è¯†åˆ«ä¼˜åŒ–é€‰é¡¹
        </div>
        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 8px;">
          <input
            type="checkbox"
            id="enablePreprocess"
            checked
            style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;"
          />
          <span style="color: #333;">å¯ç”¨å›¾åƒé¢„å¤„ç†ï¼ˆå¢å¼ºå¯¹æ¯”åº¦ï¼Œæå‡è¯†åˆ«ç‡ï¼‰</span>
        </label>
        <label style="display: flex; align-items: center; cursor: pointer; margin-bottom: 12px;">
          <input
            type="checkbox"
            id="enableOptimizeSize"
            checked
            style="margin-right: 8px; width: 18px; height: 18px; cursor: pointer;"
          />
          <span style="color: #333;">è‡ªåŠ¨ä¼˜åŒ–å›¾åƒå°ºå¯¸ï¼ˆå¤§å›¾è‡ªåŠ¨ç¼©æ”¾ï¼‰</span>
        </label>
        <div style="margin-top: 10px; margin-bottom: 12px;">
          <label style="display: block; color: #333; margin-bottom: 6px; font-weight: 500;">
            é¢„å¤„ç†æ¨¡å¼ï¼š
          </label>
          <select
            id="preprocessMode"
            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: white;"
          >
            <option value="enhance">å¢å¼ºæ¨¡å¼ï¼ˆå¯¹æ¯”åº¦+é”åŒ–ï¼Œæ¨èï¼‰</option>
            <option value="binary">äºŒå€¼åŒ–æ¨¡å¼ï¼ˆé»‘ç™½åŒ–ï¼Œé€‚åˆæ¸…æ™°æ–‡å­—ï¼‰</option>
            <option value="aggressive">æ¿€è¿›æ¨¡å¼ï¼ˆæœ€å¼ºå¤„ç†ï¼Œé€‚åˆæ¨¡ç³Šå›¾ç‰‡ï¼‰</option>
            <option value="none">æ— é¢„å¤„ç†ï¼ˆä½¿ç”¨åŸå›¾ï¼‰</option>
          </select>
        </div>
        <div style="margin-top: 10px;">
          <label style="display: block; color: #333; margin-bottom: 6px; font-weight: 500;">
            é¡µé¢åˆ†å‰²æ¨¡å¼ï¼ˆPSMï¼‰ï¼š
          </label>
          <select
            id="psmMode"
            style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 14px; background: white;"
          >
            <option value="6">6 - ç»Ÿä¸€æ–‡æœ¬å—ï¼ˆæ¨èï¼Œé€‚åˆå¤§å¤šæ•°æƒ…å†µï¼‰</option>
            <option value="7">7 - å•è¡Œæ–‡æœ¬ï¼ˆé€‚åˆå•è¡Œæ–‡å­—ï¼‰</option>
            <option value="11">11 - ç¨€ç–æ–‡æœ¬ï¼ˆé€‚åˆä¸è§„åˆ™å¸ƒå±€ï¼‰</option>
            <option value="13">13 - åŸå§‹è¡Œï¼ˆé€‚åˆå¤šè¡Œæ–‡æœ¬ï¼‰</option>
            <option value="3">3 - è‡ªåŠ¨ï¼ˆè®©OCRè‡ªåŠ¨åˆ¤æ–­ï¼‰</option>
          </select>
        </div>
      </div>

      <div class="button-group">
        <button class="button" id="recognizeBtn" disabled>
          å¼€å§‹è¯†åˆ«
        </button>
        <button class="button button-clear" id="clearBtn">
          æ¸…é™¤
        </button>
      </div>

      <div class="progress-section hidden" id="progressSection">
        <div class="progress-bar">
          <div class="progress-fill" id="progressFill"></div>
        </div>
        <div class="progress-text" id="progressText">å‡†å¤‡ä¸­...</div>
      </div>

      <div class="result-section hidden" id="resultSection">
        <div class="result-title">è¯†åˆ«ç»“æœ</div>
        <div class="result-content">
          <div class="result-text" id="resultText"></div>
          <button
            class="button"
            id="copyBtn"
            style="margin-top: 15px; padding: 10px 20px; font-size: 14px;"
          >
            ğŸ“‹ å¤åˆ¶è¯†åˆ«ç»“æœ
          </button>
        </div>
        <div class="detection-result" id="detectionResult"></div>
      </div>
    </div>

    <script>
      const uploadArea = document.getElementById("uploadArea");
      const fileInput = document.getElementById("fileInput");
      const previewSection = document.getElementById("previewSection");
      const previewImage = document.getElementById("previewImage");
      const recognizeBtn = document.getElementById("recognizeBtn");
      const progressSection = document.getElementById("progressSection");
      const progressFill = document.getElementById("progressFill");
      const progressText = document.getElementById("progressText");
      const resultSection = document.getElementById("resultSection");
      const resultText = document.getElementById("resultText");
      const detectionResult = document.getElementById("detectionResult");
      const clearBtn = document.getElementById("clearBtn");
      const copyBtn = document.getElementById("copyBtn");
      const statusInfo = document.getElementById("statusInfo");
      const statusText = document.getElementById("statusText");
      const enablePreprocess = document.getElementById("enablePreprocess");
      const enableOptimizeSize = document.getElementById("enableOptimizeSize");
      const psmMode = document.getElementById("psmMode");
      const preprocessMode = document.getElementById("preprocessMode");

      let currentImage = null;
      let Tesseract = null;
      let tesseractLoading = false;
      let recognizedText = ""; // ä¿å­˜è¯†åˆ«ç»“æœç”¨äºå¤åˆ¶

      // å›¾åƒé¢„å¤„ç†å‡½æ•° - æå‡OCRè¯†åˆ«ç‡
      function preprocessImage(imageSrc, mode = "enhance") {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            
            // è®¾ç½®ç”»å¸ƒå°ºå¯¸ï¼ˆæé«˜åˆ†è¾¨ç‡æœ‰åŠ©äºè¯†åˆ«ï¼‰
            // å¦‚æœå›¾åƒå¤ªå°ï¼Œæ”¾å¤§åˆ°è‡³å°‘300DPI
            let scale = 1;
            const minDPI = 300;
            const currentDPI = Math.min(img.width, img.height) / Math.max(img.width, img.height) * 96;
            if (currentDPI < minDPI) {
              scale = minDPI / currentDPI;
            }
            
            canvas.width = Math.floor(img.width * scale);
            canvas.height = Math.floor(img.height * scale);
            
            // é«˜è´¨é‡ç¼©æ”¾
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = "high";
            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
            
            // è·å–å›¾åƒæ•°æ®
            let imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            let data = imageData.data;
            
            if (mode === "none") {
              const processedImage = canvas.toDataURL("image/png", 1.0);
              resolve(processedImage);
              return;
            }
            
            // è½¬æ¢ä¸ºç°åº¦å›¾å¹¶è®¡ç®—ç»Ÿè®¡ä¿¡æ¯
            let sum = 0;
            const grayscale = [];
            for (let i = 0; i < data.length; i += 4) {
              const r = data[i];
              const g = data[i + 1];
              const b = data[i + 2];
              const gray = 0.299 * r + 0.587 * g + 0.114 * b;
              grayscale.push(gray);
              sum += gray;
            }
            const avgBrightness = sum / (data.length / 4);
            
            // è®¡ç®—è‡ªé€‚åº”é˜ˆå€¼ï¼ˆOTSUç®—æ³•ç®€åŒ–ç‰ˆï¼‰
            let threshold = avgBrightness;
            if (mode === "binary" || mode === "aggressive") {
              // è®¡ç®—ç›´æ–¹å›¾
              const histogram = new Array(256).fill(0);
              grayscale.forEach(g => histogram[Math.floor(g)]++);
              
              // æ‰¾åˆ°æœ€ä½³é˜ˆå€¼
              let maxVariance = 0;
              for (let t = 0; t < 256; t++) {
                let w0 = 0, w1 = 0, u0 = 0, u1 = 0;
                for (let i = 0; i <= t; i++) {
                  w0 += histogram[i];
                  u0 += i * histogram[i];
                }
                for (let i = t + 1; i < 256; i++) {
                  w1 += histogram[i];
                  u1 += i * histogram[i];
                }
                if (w0 > 0 && w1 > 0) {
                  u0 /= w0;
                  u1 /= w1;
                  const variance = w0 * w1 * (u0 - u1) * (u0 - u1);
                  if (variance > maxVariance) {
                    maxVariance = variance;
                    threshold = t;
                  }
                }
              }
            }
            
            // åº”ç”¨ä¸åŒçš„é¢„å¤„ç†æ¨¡å¼
            for (let i = 0; i < data.length; i += 4) {
              let gray = grayscale[i / 4];
              
              if (mode === "enhance") {
                // å¢å¼ºæ¨¡å¼ï¼šå¯¹æ¯”åº¦+é”åŒ–
                const contrast = avgBrightness < 128 ? 2.0 : 1.6;
                const brightness = avgBrightness < 128 ? 15 : 5;
                gray = (gray - 128) * contrast + 128 + brightness;
                
                // åº”ç”¨é”åŒ–ï¼ˆç®€åŒ–ç‰ˆï¼‰
                if (i > canvas.width * 4 && i < data.length - canvas.width * 4) {
                  const prevGray = grayscale[(i / 4) - 1] || gray;
                  const nextGray = grayscale[(i / 4) + 1] || gray;
                  gray = gray * 1.2 - (prevGray + nextGray) * 0.1;
                }
              } else if (mode === "binary") {
                // äºŒå€¼åŒ–æ¨¡å¼ï¼šé»‘ç™½åŒ–
                gray = gray > threshold ? 255 : 0;
              } else if (mode === "aggressive") {
                // æ¿€è¿›æ¨¡å¼ï¼šå¼ºå¯¹æ¯”åº¦+äºŒå€¼åŒ–+é”åŒ–
                const contrast = 2.5;
                gray = (gray - 128) * contrast + 128;
                gray = gray > threshold ? 255 : 0;
                
                // é”åŒ–
                if (i > canvas.width * 4 && i < data.length - canvas.width * 4) {
                  const prevGray = grayscale[(i / 4) - 1] || gray;
                  const nextGray = grayscale[(i / 4) + 1] || gray;
                  gray = Math.min(255, Math.max(0, gray * 1.3 - (prevGray + nextGray) * 0.15));
                }
              }
              
              // é™åˆ¶èŒƒå›´
              gray = Math.min(255, Math.max(0, gray));
              
              // åº”ç”¨åˆ°RGBé€šé“
              data[i] = data[i + 1] = data[i + 2] = gray;
            }
            
            // å»å™ªå¤„ç†ï¼ˆç®€å•ä¸­å€¼æ»¤æ³¢ï¼Œä»…å¯¹äºŒå€¼åŒ–æ¨¡å¼ï¼‰
            if (mode === "binary" || mode === "aggressive") {
              const denoisedData = new Uint8ClampedArray(data);
              for (let y = 1; y < canvas.height - 1; y++) {
                for (let x = 1; x < canvas.width - 1; x++) {
                  const idx = (y * canvas.width + x) * 4;
                  const neighbors = [
                    data[idx],
                    data[(idx - canvas.width * 4)],
                    data[(idx + canvas.width * 4)],
                    data[(idx - 4)],
                    data[(idx + 4)]
                  ];
                  neighbors.sort((a, b) => a - b);
                  const median = neighbors[2];
                  denoisedData[idx] = denoisedData[idx + 1] = denoisedData[idx + 2] = median;
                }
              }
              data = denoisedData;
            }
            
            // åº”ç”¨å¤„ç†åçš„å›¾åƒæ•°æ®
            imageData.data.set(data);
            ctx.putImageData(imageData, 0, 0);
            
            // è½¬æ¢ä¸ºDataURL
            const processedImage = canvas.toDataURL("image/png", 1.0);
            resolve(processedImage);
          };
          img.src = imageSrc;
        });
      }

      // å›¾åƒç¼©æ”¾ä¼˜åŒ–ï¼ˆç¡®ä¿åˆ†è¾¨ç‡è¶³å¤Ÿï¼ŒåŒæ—¶é¿å…è¿‡å¤§ï¼‰
      function optimizeImageSize(imageSrc, maxWidth = 3000, maxHeight = 3000, minDPI = 200) {
        return new Promise((resolve) => {
          const img = new Image();
          img.onload = () => {
            let width = img.width;
            let height = img.height;
            
            // è®¡ç®—å½“å‰DPIï¼ˆä¼°ç®—ï¼‰
            const diagonal = Math.sqrt(width * width + height * height);
            const currentDPI = (diagonal / Math.max(width, height)) * 96;
            
            // å¦‚æœå›¾åƒå¤ªå°ï¼Œæ”¾å¤§åˆ°è‡³å°‘minDPI
            if (currentDPI < minDPI) {
              const scale = minDPI / currentDPI;
              width = Math.floor(width * scale);
              height = Math.floor(height * scale);
            }
            
            // å¦‚æœå›¾åƒå¤ªå¤§ï¼Œè¿›è¡Œç¼©æ”¾ï¼ˆä½†ä¿æŒæ¯”ä¾‹ï¼‰
            if (width > maxWidth || height > maxHeight) {
              const ratio = Math.min(maxWidth / width, maxHeight / height);
              width = Math.floor(width * ratio);
              height = Math.floor(height * ratio);
            }
            
            // å¦‚æœå°ºå¯¸æ²¡æœ‰å˜åŒ–ï¼Œç›´æ¥è¿”å›åŸå›¾
            if (width === img.width && height === img.height) {
              resolve(imageSrc);
              return;
            }
            
            const canvas = document.createElement("canvas");
            const ctx = canvas.getContext("2d");
            canvas.width = width;
            canvas.height = height;
            
            // ä½¿ç”¨é«˜è´¨é‡ç¼©æ”¾
            ctx.imageSmoothingEnabled = true;
            ctx.imageSmoothingQuality = "high";
            ctx.drawImage(img, 0, 0, width, height);
            
            const optimizedImage = canvas.toDataURL("image/png", 1.0);
            resolve(optimizedImage);
          };
          img.src = imageSrc;
        });
      }

      // æ›´æ–°çŠ¶æ€ä¿¡æ¯
      function updateStatus(message, type = "info") {
        statusText.textContent = message;
        statusInfo.className = `status-info ${type}`;
        if (type === "info" && message.includes("å°±ç»ª")) {
          statusInfo.classList.add("hidden");
        } else {
          statusInfo.classList.remove("hidden");
        }
      }

      // åŠ¨æ€åŠ è½½ Tesseract.jsï¼ˆä»…ä½¿ç”¨æœ¬åœ°æ–‡ä»¶ï¼‰
      function loadTesseract() {
        return new Promise((resolve, reject) => {
          // å¦‚æœå·²ç»åŠ è½½ï¼Œç›´æ¥è¿”å›
          if (Tesseract) {
            resolve();
            return;
          }

          // å¦‚æœæ­£åœ¨åŠ è½½ï¼Œç­‰å¾…åŠ è½½å®Œæˆ
          if (tesseractLoading) {
            const checkInterval = setInterval(() => {
              if (Tesseract) {
                clearInterval(checkInterval);
                resolve();
              }
            }, 100);
            return;
          }

          tesseractLoading = true;
          progressText.textContent = "æ­£åœ¨åŠ è½½OCRåº“...";
          updateStatus("æ­£åœ¨åŠ è½½OCRåº“...", "loading");

          // æœ¬åœ°æ–‡ä»¶è·¯å¾„ï¼ˆTesseract.js 7.xï¼‰
          const localPath = "js/tesseract/tesseract.min.js";
          const localWorkerPath = "js/tesseract/worker.min.js";
          const localLangPath = "js/tesseract";
          // 7.xç‰ˆæœ¬çš„è¯­è¨€åŒ…é€šå¸¸æ”¾åœ¨æ ¹ç›®å½•æˆ–ç‰ˆæœ¬ç›®å½•ä¸‹
          // å¦‚æœè¯­è¨€åŒ…åœ¨å­ç›®å½•ï¼Œè·¯å¾„åº”è¯¥æ˜¯ "js/tesseract/4.0.0" æˆ– "js/tesseract"

          const script = document.createElement("script");
          script.src = localPath;

          script.onload = () => {
            // ç­‰å¾…ä¸€ä¸‹ç¡®ä¿å…¨å±€å˜é‡å·²è®¾ç½®
            setTimeout(() => {
              if (typeof window.Tesseract !== "undefined") {
                Tesseract = window.Tesseract;
                
                // é…ç½®æœ¬åœ° worker å’Œè¯­è¨€æ¨¡å‹è·¯å¾„ï¼ˆTesseract.js 7.xï¼‰
                try {
                  if (Tesseract.setOptions) {
                    // 7.xç‰ˆæœ¬æ”¯æŒæ›´å®Œæ•´çš„é…ç½®é€‰é¡¹
                    const options = {
                      workerPath: localWorkerPath,
                      langPath: localLangPath,
                      // 7.xç‰ˆæœ¬å¯èƒ½éœ€è¦corePathï¼Œå¦‚æœæœ¬åœ°æœ‰çš„è¯
                      // corePath: "js/tesseract/tesseract-core.wasm.js",
                    };
                    Tesseract.setOptions(options);
                    console.log("Tesseract.js 7.0.0 é…ç½®å®Œæˆï¼Œä½¿ç”¨æœ¬åœ°èµ„æº");
                    console.log("Workerè·¯å¾„:", localWorkerPath);
                    console.log("è¯­è¨€åŒ…è·¯å¾„:", localLangPath);
                    console.log("ç‰ˆæœ¬: 7.0.0");
                  }
                } catch (e) {
                  console.warn("è®¾ç½® Tesseract é€‰é¡¹å¤±è´¥:", e);
                }
                
                tesseractLoading = false;
                updateStatus("OCRåº“åŠ è½½å®Œæˆï¼Œå¯ä»¥å¼€å§‹è¯†åˆ«", "info");
                setTimeout(() => {
                  updateStatus("", "info");
                }, 2000);
                resolve();
              } else {
                tesseractLoading = false;
                updateStatus("Tesseract.js æœªæ­£ç¡®åŠ è½½ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨", "error");
                reject(new Error("Tesseract.js æœªæ­£ç¡®åŠ è½½ï¼Œè¯·æ£€æŸ¥ js/tesseract/tesseract.min.js æ–‡ä»¶æ˜¯å¦å­˜åœ¨"));
              }
            }, 100);
          };

          script.onerror = () => {
            tesseractLoading = false;
            const errorMsg = `æœ¬åœ°OCRåº“ï¼ˆTesseract.js 7.xï¼‰åŠ è½½å¤±è´¥ï¼Œè¯·ç¡®ä¿ä»¥ä¸‹æ–‡ä»¶å­˜åœ¨ï¼š\n- ${localPath}\n- ${localWorkerPath}\n- ${localLangPath}/4.0.0/chi_sim.traineddata.gz æˆ– ${localLangPath}/chi_sim.traineddata.gz`;
            updateStatus("æœ¬åœ°OCRåº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦å­˜åœ¨", "error");
            reject(new Error(errorMsg));
          };

          document.head.appendChild(script);
        });
      }

      // é¡µé¢åŠ è½½å®ŒæˆååŠ è½½åº“
      window.addEventListener("load", async () => {
        try {
          await loadTesseract();
          console.log("Tesseract.js å‡†å¤‡å°±ç»ª");
        } catch (error) {
          console.error("Tesseract.js åŠ è½½å¤±è´¥:", error);
          recognizeBtn.disabled = true;
          recognizeBtn.textContent = "OCRåº“åŠ è½½å¤±è´¥ï¼Œè¯·åˆ·æ–°é¡µé¢";
          updateStatus("OCRåº“åŠ è½½å¤±è´¥: " + error.message, "error");
          alert("OCRåº“åŠ è½½å¤±è´¥: " + error.message);
        }
      });

      // ç‚¹å‡»ä¸Šä¼ åŒºåŸŸ
      uploadArea.addEventListener("click", () => {
        fileInput.click();
      });

      // æ–‡ä»¶é€‰æ‹©
      fileInput.addEventListener("change", (e) => {
        const file = e.target.files[0];
        if (file) {
          handleFile(file);
        }
      });

      // æ‹–æ‹½ä¸Šä¼ 
      uploadArea.addEventListener("dragover", (e) => {
        e.preventDefault();
        uploadArea.classList.add("dragover");
      });

      uploadArea.addEventListener("dragleave", () => {
        uploadArea.classList.remove("dragover");
      });

      uploadArea.addEventListener("drop", (e) => {
        e.preventDefault();
        uploadArea.classList.remove("dragover");
        const file = e.dataTransfer.files[0];
        if (file && file.type.startsWith("image/")) {
          handleFile(file);
        }
      });

      // å¤„ç†æ–‡ä»¶
      function handleFile(file) {
        // éªŒè¯æ–‡ä»¶ç±»å‹
        if (!file.type.startsWith("image/")) {
          alert("è¯·é€‰æ‹©å›¾ç‰‡æ–‡ä»¶ï¼");
          return;
        }

        // éªŒè¯æ–‡ä»¶å¤§å°ï¼ˆé™åˆ¶ä¸º10MBï¼‰
        if (file.size > 10 * 1024 * 1024) {
          alert("å›¾ç‰‡æ–‡ä»¶è¿‡å¤§ï¼Œè¯·é€‰æ‹©å°äº10MBçš„å›¾ç‰‡ï¼");
          return;
        }

        const reader = new FileReader();
        reader.onload = (e) => {
          currentImage = e.target.result;
          previewImage.src = currentImage;
          previewSection.classList.remove("hidden");
          recognizeBtn.disabled = false;
          resultSection.classList.add("hidden");
          recognizedText = ""; // æ¸…ç©ºä¹‹å‰çš„è¯†åˆ«ç»“æœ
        };
        reader.onerror = () => {
          alert("æ–‡ä»¶è¯»å–å¤±è´¥ï¼Œè¯·é‡è¯•ï¼");
        };
        reader.readAsDataURL(file);
      }

      // æ¸…é™¤åŠŸèƒ½
      clearBtn.addEventListener("click", () => {
        currentImage = null;
        recognizedText = "";
        previewImage.src = "";
        previewSection.classList.add("hidden");
        resultSection.classList.add("hidden");
        progressSection.classList.add("hidden");
        recognizeBtn.disabled = true;
        fileInput.value = "";
        progressFill.style.width = "0%";
      });

      // å¤åˆ¶åŠŸèƒ½
      copyBtn.addEventListener("click", async () => {
        if (!recognizedText) {
          alert("æ²¡æœ‰å¯å¤åˆ¶çš„å†…å®¹ï¼");
          return;
        }

        try {
          await navigator.clipboard.writeText(recognizedText);
          const originalText = copyBtn.textContent;
          copyBtn.textContent = "âœ… å·²å¤åˆ¶ï¼";
          copyBtn.style.background = "#28a745";
          setTimeout(() => {
            copyBtn.textContent = originalText;
            copyBtn.style.background = "";
          }, 2000);
        } catch (err) {
          // é™çº§æ–¹æ¡ˆï¼šä½¿ç”¨ä¼ ç»Ÿæ–¹æ³•
          const textArea = document.createElement("textarea");
          textArea.value = recognizedText;
          textArea.style.position = "fixed";
          textArea.style.opacity = "0";
          document.body.appendChild(textArea);
          textArea.select();
          try {
            document.execCommand("copy");
            const originalText = copyBtn.textContent;
            copyBtn.textContent = "âœ… å·²å¤åˆ¶ï¼";
            copyBtn.style.background = "#28a745";
            setTimeout(() => {
              copyBtn.textContent = originalText;
              copyBtn.style.background = "";
            }, 2000);
          } catch (e) {
            alert("å¤åˆ¶å¤±è´¥ï¼Œè¯·æ‰‹åŠ¨å¤åˆ¶æ–‡æœ¬");
          }
          document.body.removeChild(textArea);
        }
      });

      // å¼€å§‹è¯†åˆ«
      recognizeBtn.addEventListener("click", async () => {
        if (!currentImage) return;

        // ç¡®ä¿ Tesseract å·²åŠ è½½
        if (!Tesseract) {
          try {
            await loadTesseract();
          } catch (error) {
            alert("OCRåº“æœªåŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•: " + error.message);
            return;
          }
        }

        recognizeBtn.disabled = true;
        progressSection.classList.remove("hidden");
        resultSection.classList.add("hidden");

        try {
          let processedImage = currentImage;
          
          // æ ¹æ®ç”¨æˆ·é€‰é¡¹è¿›è¡Œå›¾åƒé¢„å¤„ç†
          if (enableOptimizeSize.checked) {
            progressText.textContent = "ä¼˜åŒ–å›¾åƒå°ºå¯¸...";
            progressFill.style.width = "5%";
            processedImage = await optimizeImageSize(processedImage);
          }
          
          if (enablePreprocess.checked) {
            const mode = preprocessMode.value;
            const modeNames = {
              enhance: "å¢å¼ºæ¨¡å¼",
              binary: "äºŒå€¼åŒ–æ¨¡å¼",
              aggressive: "æ¿€è¿›æ¨¡å¼",
              none: "æ— é¢„å¤„ç†"
            };
            progressText.textContent = `é¢„å¤„ç†å›¾åƒä¸­ï¼ˆ${modeNames[mode]}ï¼‰...`;
            progressFill.style.width = "7%";
            processedImage = await preprocessImage(processedImage, mode);
          }
          
          progressText.textContent = "åˆå§‹åŒ–OCRå¼•æ“...";
          progressFill.style.width = "10%";

          // åˆå§‹åŒ–Tesseract.js 7.xï¼ˆä½¿ç”¨æœ¬åœ°è¯­è¨€åŒ…ï¼‰
          // ä¼˜åŒ–é…ç½®ï¼šä½¿ç”¨LSTMå¼•æ“ï¼ˆ1ï¼‰ï¼Œé€‚åˆä¸­æ–‡è¯†åˆ«
          const worker = await Tesseract.createWorker("chi_sim", 1, {
            logger: (m) => {
              // 7.xç‰ˆæœ¬çš„çŠ¶æ€æ¶ˆæ¯å¯èƒ½ç•¥æœ‰ä¸åŒï¼Œä½†åŸºæœ¬å…¼å®¹
              if (m.status === "recognizing text") {
                const progress = Math.round(m.progress * 100);
                progressFill.style.width = Math.min(95, 10 + progress * 0.85) + "%";
                progressText.textContent = `è¯†åˆ«ä¸­... ${progress}%`;
              } else if (m.status === "loading tesseract core" || m.status === "loading tesseract core wasm") {
                progressText.textContent = "åŠ è½½OCRå¼•æ“ï¼ˆæœ¬åœ° 7.xï¼‰...";
                progressFill.style.width = "15%";
              } else if (m.status === "initializing tesseract") {
                progressText.textContent = "åˆå§‹åŒ–ä¸­...";
                progressFill.style.width = "20%";
              } else if (m.status === "loading language traineddata" || m.status === "loading language") {
                progressText.textContent = "åŠ è½½è¯­è¨€æ¨¡å‹ï¼ˆæœ¬åœ° 7.xï¼‰...";
                progressFill.style.width = "30%";
              } else if (m.status === "loading tesseract") {
                progressText.textContent = "åŠ è½½Tesseractï¼ˆæœ¬åœ° 7.xï¼‰...";
                progressFill.style.width = "12%";
              } else if (m.status) {
                // 7.xå¯èƒ½æœ‰ä¸€äº›æ–°çš„çŠ¶æ€ï¼Œæ˜¾ç¤ºå‡ºæ¥ä»¥ä¾¿è°ƒè¯•
                progressText.textContent = `å¤„ç†ä¸­: ${m.status}...`;
              }
            },
          });

          // è®¾ç½®OCRå‚æ•°ä»¥ä¼˜åŒ–ä¸­æ–‡è¯†åˆ«
          const selectedPSM = psmMode.value;
          
          // åŸºç¡€å‚æ•° - é’ˆå¯¹ä¸­æ–‡ä¼˜åŒ–
          const ocrParams = {
            tessedit_pageseg_mode: selectedPSM, // ä½¿ç”¨ç”¨æˆ·é€‰æ‹©çš„PSMæ¨¡å¼
            tessedit_ocr_engine_mode: "1", // LSTMå¼•æ“ï¼Œé€‚åˆä¸­æ–‡
            
            // ä¸­æ–‡è¯†åˆ«ä¼˜åŒ– - é™ä½æƒ©ç½šä»¥æé«˜è¯†åˆ«ç‡
            language_model_penalty_non_freq_dict_word: "0.05", // è¿›ä¸€æ­¥é™ä½éé¢‘ç¹å­—å…¸è¯çš„æƒ©ç½š
            language_model_penalty_non_dict_word: "0.1", // è¿›ä¸€æ­¥é™ä½éå­—å…¸è¯çš„æƒ©ç½š
            language_model_penalty_punc: "0.1", // é™ä½æ ‡ç‚¹ç¬¦å·æƒ©ç½š
            
            // å­—ç¬¦è¯†åˆ«ä¼˜åŒ–
            classify_bln_numeric_mode: "0", // ä¸å¼ºåˆ¶æ•°å­—æ¨¡å¼
            textord_min_linesize: "2.0", // é™ä½æœ€å°è¡Œå°ºå¯¸ï¼Œè¯†åˆ«æ›´å°æ–‡å­—
            textord_tabvector_vertical_gap_factor: "0.5", // ä¼˜åŒ–å‚ç›´é—´è·
            
            // æé«˜è¯†åˆ«è´¨é‡
            preserve_interword_spaces: "1", // ä¿ç•™è¯é—´ç©ºæ ¼
            tessedit_char_whitelist: "", // ä¸é™åˆ¶å­—ç¬¦é›†ï¼Œå…è®¸æ‰€æœ‰ä¸­æ–‡å­—ç¬¦
            
            // ä¸­æ–‡ç‰¹å®šè®¾ç½®
            segment_segcost_rating: "0", // åˆ†å‰²æˆæœ¬è¯„åˆ†
            segment_reward_script: "1", // è„šæœ¬å¥–åŠ±
            
            // æé«˜è¯†åˆ«ç²¾åº¦
            classify_enable_learning: "0", // ç¦ç”¨å­¦ä¹ æ¨¡å¼ä»¥æé«˜é€Ÿåº¦
            classify_enable_adaptive_matcher: "1", // å¯ç”¨è‡ªé€‚åº”åŒ¹é…å™¨
            
            // ä¼˜åŒ–å­—ç¬¦åˆ†å‰²
            wordrec_enable_assoc: "1", // å¯ç”¨å…³è”
            wordrec_max_join_chunks: "30", // æœ€å¤§è¿æ¥å—æ•°
            
            // ä¸­æ–‡è¯†åˆ«ç‰¹å®šä¼˜åŒ–
            load_system_dawg: "0", // ä¸åŠ è½½ç³»ç»Ÿå­—å…¸ï¼ˆä¸­æ–‡ä¸éœ€è¦ï¼‰
            load_freq_dawg: "0", // ä¸åŠ è½½é¢‘ç‡å­—å…¸
            load_unambig_dawg: "0", // ä¸åŠ è½½æ˜ç¡®å­—å…¸
            load_punc_dawg: "0", // ä¸åŠ è½½æ ‡ç‚¹å­—å…¸
            load_number_dawg: "0", // ä¸åŠ è½½æ•°å­—å­—å…¸
          };
          
          await worker.setParameters(ocrParams);
          
          console.log("OCRå‚æ•°å·²è®¾ç½®:", {
            PSMæ¨¡å¼: selectedPSM,
            å¼•æ“: "LSTM",
            é¢„å¤„ç†: enablePreprocess.checked ? "å·²å¯ç”¨" : "æœªå¯ç”¨",
            å°ºå¯¸ä¼˜åŒ–: enableOptimizeSize.checked ? "å·²å¯ç”¨" : "æœªå¯ç”¨",
          });

          progressText.textContent = "å¼€å§‹è¯†åˆ«...";
          progressFill.style.width = "40%";

          // æ‰§è¡ŒOCRè¯†åˆ«ï¼ˆä½¿ç”¨é¢„å¤„ç†åçš„å›¾åƒï¼‰
          // Tesseract.js 7.x: ä¸ä¼ é€’rectangleå‚æ•°è¡¨ç¤ºè¯†åˆ«æ•´ä¸ªå›¾åƒ
          const {
            data: { text },
          } = await worker.recognize(processedImage);

          // ç»ˆæ­¢worker
          await worker.terminate();

          // ä¿å­˜åŸå§‹æ–‡æœ¬ç”¨äºå¤åˆ¶
          recognizedText = text || "";

          // æ˜¾ç¤ºè¯†åˆ«ç»“æœï¼ˆå…ˆæ¸…ç©ºï¼Œåé¢ä¼šè®¾ç½®é«˜äº®æ–‡æœ¬ï¼‰
          resultSection.classList.remove("hidden");
          progressSection.classList.add("hidden");
          progressFill.style.width = "100%";
          progressText.textContent = "è¯†åˆ«å®Œæˆ";

          // æ£€æµ‹æ˜¯å¦åŒ…å«"ç”µç½‘"ï¼ˆæ”¯æŒå¤šç§å˜ä½“ï¼‰
          const targetKeywords = ["ç”µç½‘", "é›»ç¶²"]; // æ”¯æŒç®€ä½“ä¸­æ–‡å’Œç¹ä½“ä¸­æ–‡
          const hasTargetText = targetKeywords.some((keyword) =>
            text.includes(keyword)
          );
          
          // é«˜äº®æ˜¾ç¤ºåŒ¹é…çš„å…³é”®è¯
          let highlightedText = text || "(æœªè¯†åˆ«åˆ°æ–‡å­—)";
          if (hasTargetText && text) {
            targetKeywords.forEach((keyword) => {
              const regex = new RegExp(`(${keyword})`, "gi");
              highlightedText = highlightedText.replace(
                regex,
                '<mark style="background-color: #ffeb3b; padding: 2px 4px; border-radius: 3px;">$1</mark>'
              );
            });
          }
          
          resultText.innerHTML = highlightedText;
          
          detectionResult.textContent = hasTargetText
            ? `âœ… æ£€æµ‹åˆ°"${targetKeywords.find((k) => text.includes(k)) || "ç”µç½‘"}"æ–‡æ¡ˆ`
            : 'âŒ æœªæ£€æµ‹åˆ°"ç”µç½‘"æ–‡æ¡ˆ';
          detectionResult.className = `detection-result ${
            hasTargetText ? "found" : "not-found"
          }`;

          recognizeBtn.disabled = false;
        } catch (error) {
          console.error("OCRè¯†åˆ«å¤±è´¥:", error);
          progressText.textContent = "è¯†åˆ«å¤±è´¥ï¼Œè¯·é‡è¯•";
          progressFill.style.width = "0%";
          recognizeBtn.disabled = false;
          
          // æ›´å‹å¥½çš„é”™è¯¯æç¤ºï¼ˆé’ˆå¯¹æœ¬åœ°èµ„æº - Tesseract.js 7.xï¼‰
          let errorMessage = "è¯†åˆ«å¤±è´¥";
          if (error.message.includes("language") || error.message.includes("traineddata")) {
            errorMessage = `è¯­è¨€æ¨¡å‹åŠ è½½å¤±è´¥ï¼ˆTesseract.js 7.xï¼‰ï¼Œè¯·ç¡®ä¿ä»¥ä¸‹æ–‡ä»¶å­˜åœ¨ï¼š\n- js/tesseract/4.0.0/chi_sim.traineddata.gz\næˆ–\n- js/tesseract/chi_sim.traineddata.gz\n\nå¦‚æœæ–‡ä»¶å­˜åœ¨ä½†ä»å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ˜¯å¦æŸåæˆ–åˆ·æ–°é¡µé¢é‡è¯•`;
          } else if (error.message.includes("worker") || error.message.includes("core")) {
            errorMessage = `OCRå¼•æ“åˆå§‹åŒ–å¤±è´¥ï¼ˆTesseract.js 7.xï¼‰ï¼Œè¯·ç¡®ä¿ä»¥ä¸‹æ–‡ä»¶å­˜åœ¨ï¼š\n- js/tesseract/tesseract.min.js\n- js/tesseract/worker.min.js\n\nè¯·åˆ·æ–°é¡µé¢é‡è¯•`;
          } else {
            errorMessage = `è¯†åˆ«å¤±è´¥ï¼ˆTesseract.js 7.xï¼‰: ${error.message}\n\nè¯·ç¡®ä¿æ‰€æœ‰æœ¬åœ°èµ„æºæ–‡ä»¶å®Œæ•´ä¸”å¯è®¿é—®`;
          }
          
          alert(errorMessage);
        }
      });
    </script>
  </body>
</html>
