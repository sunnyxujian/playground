<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Fabric.js 图片裁剪（抗锯齿圆角）</title>
    <script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"></script>
    <style>
      body {
        font-family: system-ui, -apple-system, Segoe UI, Roboto,
          "Helvetica Neue", Arial;
        margin: 18px;
        background: #f6f8fa;
        color: #111;
      }
      h1 {
        font-size: 18px;
        margin: 0 0 12px;
      }
      #app {
        display: flex;
        gap: 16px;
        align-items: flex-start;
      }
      #controls {
        width: 300px;
        padding: 12px;
        background: #fff;
        border: 1px solid #e6e9ee;
        border-radius: 8px;
      }
      #controls label {
        display: block;
        margin: 8px 0;
        font-size: 13px;
      }
      #controls input[type="file"] {
        width: 100%;
      }
      #controls .row {
        display: flex;
        gap: 8px;
        align-items: center;
        margin-top: 8px;
      }
      .btn {
        padding: 8px 12px;
        border-radius: 6px;
        border: 0;
        background: #1677ff;
        color: #fff;
        cursor: pointer;
      }
      .btn.secondary {
        background: #6b7280;
      }
      #c {
        border: 1px solid #dfe6f0;
        background: #fff;
      }
      .small {
        font-size: 12px;
        color: #5b6570;
      }
      input[type="range"] {
        width: 100%;
      }
    </style>
  </head>
  <body>
    <h1>Fabric.js 图片裁剪（抗锯齿圆角） Demo</h1>
    <div id="app">
      <div id="controls">
        <label
          >选择图片（或使用示例）
          <input id="file" type="file" accept="image/*" />
        </label>
        <div class="row">
          <button id="loadSample" class="btn">加载示例图片</button>
          <button id="reset" class="btn secondary">重置画布</button>
        </div>

        <label>圆角半径: <span id="radVal">20</span> px</label>
        <input id="radius" type="range" min="0" max="200" value="20" />

        <label
          >抗锯齿缩放倍数（越高越平滑，性能下降）:
          <span id="scaleVal">2</span>x</label
        >
        <input id="scaleFactor" type="range" min="1" max="4" value="2" />

        <div style="margin-top: 10px">
          <button id="cropBtn" class="btn">裁剪选区</button>
          <button id="exportBtn" class="btn secondary">导出 PNG</button>
        </div>

        <p class="small" style="margin-top: 10px">
          操作：拖动/缩放蓝色半透明矩形来选择裁剪区域。裁剪后会在画布中替换为裁剪结果；也可导出
          PNG（透明背景）。
        </p>
      </div>

      <div>
        <canvas id="c" width="900" height="560"></canvas>
      </div>
    </div>

    <script>
      const canvas = new fabric.Canvas("c", {
        backgroundColor: "#fff",
        preserveObjectStacking: true,
      });
      let img = null; // fabric.Image 当前原图
      let originalState = null;

      // 创建可拖拽/缩放的裁剪框（带圆角属性 rx/ry）
      const cropRect = new fabric.Rect({
        left: 180,
        top: 120,
        width: 300,
        height: 220,
        fill: "rgba(6,78,212,0.16)",
        stroke: "#0650d4",
        strokeWidth: 2,
        cornerColor: "#0650d4",
        transparentCorners: false,
        hasRotatingPoint: false,
        lockRotation: true,
        rx: 20,
        ry: 20,
      });
      canvas.add(cropRect);
      canvas.setActiveObject(cropRect);

      // 加载示例图或本地文件
      document.getElementById("loadSample").addEventListener("click", () => {
        loadImage("https://picsum.photos/1200/800");
      });

      document.getElementById("file").addEventListener("change", (e) => {
        const f = e.target.files && e.target.files[0];
        if (!f) return;
        const url = URL.createObjectURL(f);
        loadImage(url, () => URL.revokeObjectURL(url));
      });

      document.getElementById("reset").addEventListener("click", () => {
        if (originalState) {
          canvas.clear();
          canvas.loadFromJSON(originalState, () => {
            canvas.renderAll();
            cropRect.bringToFront();
          });
          // ensure cropRect exists
          if (!canvas.getObjects().includes(cropRect)) canvas.add(cropRect);
        }
      });

      document.getElementById("radius").addEventListener("input", (e) => {
        const v = parseInt(e.target.value, 10) || 0;
        document.getElementById("radVal").innerText = v;
        cropRect.set({ rx: v, ry: v });
        canvas.requestRenderAll();
      });

      document.getElementById("scaleFactor").addEventListener("input", (e) => {
        document.getElementById("scaleVal").innerText = e.target.value;
      });

      // load image helper
      function loadImage(url, cb) {
        fabric.Image.fromURL(
          url,
          function (oImg) {
            // fit to canvas while preserving aspect
            const maxW = canvas.getWidth();
            const maxH = canvas.getHeight();
            const scale = Math.min(maxW / oImg.width, maxH / oImg.height, 1);
            oImg.set({
              left: 0,
              top: 0,
              selectable: false,
              scaleX: scale,
              scaleY: scale,
            });

            // clear canvas but keep rect on top
            canvas.clear();
            canvas.add(oImg);
            img = oImg;

            // add crop rect on top
            canvas.add(cropRect);
            cropRect.bringToFront();

            canvas.setActiveObject(cropRect);
            canvas.renderAll();

            // save snapshot for reset
            originalState = JSON.stringify(canvas.toJSON(["rx", "ry"]));
            if (cb) cb();
          },
          { crossOrigin: "Anonymous" }
        );
      }

      // 辅助：绘制圆角路径（向后兼容）
      function roundRectPath(ctx, x, y, w, h, r) {
        if (!r) {
          ctx.rect(x, y, w, h);
          return;
        }
        const radius = Math.min(r, w / 2, h / 2);
        if (ctx.roundRect) {
          ctx.roundRect(x, y, w, h, radius);
          return;
        }
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + w - radius, y);
        ctx.quadraticCurveTo(x + w, y, x + w, y + radius);
        ctx.lineTo(x + w, y + h - radius);
        ctx.quadraticCurveTo(x + w, y + h, x + w - radius, y + h);
        ctx.lineTo(x + radius, y + h);
        ctx.quadraticCurveTo(x, y + h, x, y + h - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
      }

      // 主裁剪函数（高分辨率 + mask 混合）
      function cropWithSmoothRoundedCorner() {
        if (!img) {
          alert("请先加载图片");
          return;
        }

        // 真实显示尺寸考虑 scale
        const rectWidth = cropRect.width * cropRect.scaleX;
        const rectHeight = cropRect.height * cropRect.scaleY;
        const rectLeft = cropRect.left;
        const rectTop = cropRect.top;
        const radius = cropRect.rx || 0;

        // 计算裁剪源在原始图片坐标系的位置
        const sx = (rectLeft - img.left) / (img.scaleX || 1);
        const sy = (rectTop - img.top) / (img.scaleY || 1);
        const sw = rectWidth / (img.scaleX || 1);
        const sh = rectHeight / (img.scaleY || 1);

        // high-res render
        const scaleFactor =
          parseInt(document.getElementById("scaleFactor").value, 10) || 2;
        const temp = document.createElement("canvas");
        temp.width = Math.max(1, Math.round(rectWidth * scaleFactor));
        temp.height = Math.max(1, Math.round(rectHeight * scaleFactor));
        const ctx = temp.getContext("2d");
        ctx.imageSmoothingEnabled = true;
        ctx.imageSmoothingQuality = "high";

        // scale coord system so drawing uses logical sizes (not multiplied)
        ctx.scale(scaleFactor, scaleFactor);

        // draw the image portion
        try {
          ctx.drawImage(
            img._element,
            sx,
            sy,
            sw,
            sh,
            0,
            0,
            rectWidth,
            rectHeight
          );
        } catch (e) {
          console.error("drawImage error", e);
        }

        // use mask with destination-in to ensure smooth alpha edges
        ctx.globalCompositeOperation = "destination-in";
        roundRectPath(ctx, 0, 0, rectWidth, rectHeight, radius);
        ctx.fill();

        // downscale to target size
        const small = document.createElement("canvas");
        small.width = Math.max(1, Math.round(rectWidth));
        small.height = Math.max(1, Math.round(rectHeight));
        const sctx = small.getContext("2d");
        sctx.imageSmoothingEnabled = true;
        sctx.imageSmoothingQuality = "high";
        sctx.drawImage(
          temp,
          0,
          0,
          temp.width,
          temp.height,
          0,
          0,
          small.width,
          small.height
        );

        // result -> fabric image
        const resultImg = new fabric.Image(small, {
          left: rectLeft,
          top: rectTop,
          selectable: true,
        });

        // 替换画布内容：保留 resultImg（可根据需要改为叠加）
        canvas.clear();
        canvas.add(resultImg);
        canvas.setActiveObject(resultImg);
        canvas.renderAll();

        // keep new image as current img
        img = resultImg;
      }

      document
        .getElementById("cropBtn")
        .addEventListener("click", cropWithSmoothRoundedCorner);

      // 导出 PNG
      document.getElementById("exportBtn").addEventListener("click", () => {
        // 导出当前画布为 PNG，带透明背景
        const dataURL = canvas.toDataURL({ format: "png", multiplier: 1 });
        const a = document.createElement("a");
        a.href = dataURL;
        a.download = "cropped.png";
        a.click();
      });

      // load a sample on start
      loadImage("https://picsum.photos/1200/800");
    </script>
  </body>
</html>
