<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8" />
    <script src="https://cdn.jsdelivr.net/npm/fabric@5.3.0/dist/fabric.min.js"></script>
    <style>
      body {
        margin: 10px;
        font-family: sans-serif;
      }
      canvas {
        border: 1px solid #ddd;
      }
    </style>
  </head>
  <body>
    <button id="addImg">添加图片</button>
    <canvas id="c" width="800" height="500"></canvas>

    <script>
      const canvas = new fabric.Canvas("c", { preserveObjectStacking: true });

      // workspace（第一个元素，内容区域）
      const workspace = new fabric.Rect({
        left: 150,
        top: 80,
        width: 400,
        height: 300,
        fill: "#fafafa",
        selectable: false,
        evented: false,
      });
      canvas.add(workspace);

      // 使用反向 clipPath 实现超出内容半透明效果
      // 原理：创建原对象的半透明副本，使用 workspace 作为反向 clipPath
      // inverted=true 表示反向裁剪：半透明层只显示在 workspace 外部，覆盖在原对象上
      // 这样 workspace 内部保持原对象不透明，外部显示为半透明
      function applyMaskEffect(obj, workspace) {
        // 克隆原对象作为半透明层
        obj.clone((clonedObj) => {
          // 设置半透明
          clonedObj.set({
            opacity: 0.5,
            selectable: false,
            evented: false,
            excludeFromExport: true, // 导出时不包含此层
          });

          // 使用 workspace 作为 clipPath，并设置为反向裁剪
          // 这样半透明层只显示在 workspace 外部
          clonedObj.clipPath = workspace;
          clonedObj.clipPath.inverted = true;

          // 确保 clipPath 使用绝对定位（相对于 canvas）
          if (clonedObj.clipPath) {
            clonedObj.clipPath.absolutePositioned = true;
          }

          // 将半透明层添加到画布（在原对象之后添加，这样会渲染在原对象之上）
          canvas.add(clonedObj);
          // 确保半透明层在原对象之上
          clonedObj.bringToFront();

          // 当原对象变换时，需要同步更新半透明层的位置和变换
          // 使用 modified 事件（包含所有变换：移动、缩放、旋转等）
          obj.on("modified", () => {
            // 同步半透明层的所有变换属性
            clonedObj.set({
              left: obj.left,
              top: obj.top,
              angle: obj.angle,
              scaleX: obj.scaleX,
              scaleY: obj.scaleY,
              flipX: obj.flipX,
              flipY: obj.flipY,
            });
            clonedObj.setCoords();
            // 保持半透明层在原对象之上
            clonedObj.bringToFront();
            canvas.requestRenderAll();
          });

          // 监听 workspace 的变化（clipPath 会自动更新，只需重绘并保持层级）
          workspace.on("modified", () => {
            clonedObj.bringToFront();
            canvas.requestRenderAll();
          });
          workspace.on("moving", () => {
            clonedObj.bringToFront();
            canvas.requestRenderAll();
          });

          canvas.requestRenderAll();
        });
      }

      const addImg = () => {
        fabric.Image.fromURL("https://fabricjs.com/assets/pug.jpg", (img) => {
          img.set({
            left: 80,
            top: 40,
            scaleX: 0.9,
            scaleY: 0.9,
            cornerStyle: "square",
          });
          // 先添加原对象到画布
          canvas.add(img);
          // 然后应用遮罩效果（会创建半透明层并放在原对象之上）
          applyMaskEffect(img, workspace);
          canvas.setActiveObject(img);
          canvas.requestRenderAll();
        });
      };

      addImg();

      // 小提示：如果想支持任意对象（rect/text/path/etc.），都可以调用 applyMaskEffect(obj, workspace).
    </script>
  </body>
</html>
