<!DOCTYPE html>
<html>
  <head>
    <title>fabricjsè‡ªå®šä¹‰åœ†è§’çŸ©å½¢å…ƒç´ </title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <style>
      canvas {
        border: 1px solid #ccc;
      }
    </style>
  </head>
  <body>
    <div id="canvas-container">
      <canvas id="canvas" width="800" height="800"></canvas>
    </div>

    <script>
      const MIN = 10;
      const CustomRect = fabric.util.createClass(fabric.Rect, {
        type: "custom-rect",

        initialize: function (options) {
          options || (options = {});
          this.callSuper("initialize", options);

          // å¦‚æžœ maxRadius ä¸º trueï¼Œåˆ™å¿½ç•¥ radius é…ç½®
          if (options.maxRadius) {
            this.maxRadius = true;
            this.width = Math.max(this.width, MIN);
            this.height = Math.max(this.height, MIN);

            // è®¡ç®—åŠå¾„ï¼Œè·‘é“åœ†æ˜¯é«˜åº¦çš„ä¸€åŠ
            const r = Math.min(this.width, this.height) / 2 + 10;
            this.radius = [
              [r, r],
              [r, r],
              [r, r],
              [r, r],
            ];
          } else {
            this.maxRadius = false;
            this._parseRadius(options.radius || 0);
          }

          this.set({
            lockScalingX: true,
            lockScalingY: true,
            objectCaching: false,
          });

          this._initCustomControls();
        },

        _parseRadius: function (radius) {
          let r = [];

          if (typeof radius === "number") {
            r = [
              [radius, radius],
              [radius, radius],
              [radius, radius],
              [radius, radius],
            ];
          } else if (Array.isArray(radius)) {
            if (radius.length === 2) {
              r = [
                [radius[0], radius[0]],
                [radius[1], radius[1]],
                [radius[0], radius[0]],
                [radius[1], radius[1]],
              ];
            } else if (radius.length === 3) {
              r = [
                [radius[0], radius[0]],
                [radius[1], radius[1]],
                [radius[2], radius[2]],
                [radius[1], radius[1]],
              ];
            } else if (radius.length === 4) {
              r = [
                [radius[0], radius[0]],
                [radius[1], radius[1]],
                [radius[2], radius[2]],
                [radius[3], radius[3]],
              ];
            } else if (Array.isArray(radius[0])) {
              r = radius;
            }
          }

          if (!r.length) {
            r = [
              [0, 0],
              [0, 0],
              [0, 0],
              [0, 0],
            ];
          }

          this.radius = r;
        },

        _render: function (ctx) {
          const w = Math.max(this.width, MIN);
          const h = Math.max(this.height, MIN);
          const x = -w / 2,
            y = -h / 2;

          ctx.beginPath();

          if (this.maxRadius) {
            const r = h / 2; // é«˜åº¦/2
            // å·¦åŠåœ†
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r); // å³ä¸ŠåŠåœ†
            ctx.arcTo(x + w, y + h, x, y + h, r); // å³ä¸‹åŠåœ†
            ctx.arcTo(x, y + h, x, y, r); // å·¦ä¸‹åŠåœ†
            ctx.arcTo(x, y, x + w, y, r); // å·¦ä¸ŠåŠåœ†
            ctx.closePath();
          } else {
            const [tl, tr, br, bl] = this.radius;
            ctx.moveTo(x + tl[0], y);
            ctx.lineTo(x + w - tr[0], y);
            ctx.quadraticCurveTo(x + w, y, x + w, y + tr[1]);
            ctx.lineTo(x + w, y + h - br[1]);
            ctx.quadraticCurveTo(x + w, y + h, x + w - br[0], y + h);
            ctx.lineTo(x + bl[0], y + h);
            ctx.quadraticCurveTo(x, y + h, x, y + h - bl[1]);
            ctx.lineTo(x, y + tl[1]);
            ctx.quadraticCurveTo(x, y, x + tl[0], y);
            ctx.closePath();
          }

          this._renderFill(ctx);
          this._renderStroke(ctx);
        },
        _initCustomControls: function () {
          const updateSize = (target, newW, newH) => {
            newW = Math.max(1, newW);
            newH = Math.max(1, newH);

            if (target.maxRadius) {
              let radius = newH / 2;
              newH = Math.max(newH, MIN);
              radius = newH / 2;
              newW = Math.max(newW, radius * 2);
              target.radius = [
                [radius, radius],
                [radius, radius],
                [radius, radius],
                [radius, radius],
              ];
            } else if (target.radius) {
              const maxRx = Math.max(...target.radius.map((r) => r[0]));
              const maxRy = Math.max(...target.radius.map((r) => r[1]));
              newW = Math.max(newW, maxRx * 2);
              newH = Math.max(newH, maxRy * 2);
            }

            target.set({
              width: newW,
              height: newH,
              scaleX: 1,
              scaleY: 1,
            });
            target.setCoords();
          };

          // ðŸ”¹å³ä¸‹è§’ï¼ˆä¿ç•™åŽŸæœ‰ï¼‰
          this.controls.br = new fabric.Control({
            x: 0.5,
            y: 0.5,
            cursorStyle: "nwse-resize",
            actionHandler: (eventData, transform, x, y) => {
              const target = transform.target;
              const canvas = target.canvas;
              const local = target.toLocalPoint(
                new fabric.Point(x, y),
                "center",
                "center"
              );
              updateSize(
                target,
                local.x + target.width / 2,
                local.y + target.height / 2
              );
              canvas.requestRenderAll();
              return true;
            },
          });

          // ðŸ”¹ä¸Šä¸­ï¼ˆmtï¼‰
          this.controls.mt = new fabric.Control({
            x: 0,
            y: -0.5,
            cursorStyle: "ns-resize",
            actionHandler: (eventData, transform, x, y) => {
              const target = transform.target;
              const canvas = target.canvas;
              const local = target.toLocalPoint(
                new fabric.Point(x, y),
                "center",
                "center"
              );

              const newHeight = target.height - local.y * 2; // å› ä¸ºæ˜¯ä»Žä¸Šè¾¹å¾€ä¸‹æŽ¨
              const dy = (target.height - newHeight) / 2;
              target.top += dy; // å‘ä¸‹åç§»ä¸€åŠå·®å€¼

              updateSize(target, target.width, newHeight);
              canvas.requestRenderAll();
              return true;
            },
          });

          // ðŸ”¹ä¸‹ä¸­ï¼ˆmbï¼‰
          this.controls.mb = new fabric.Control({
            x: 0,
            y: 0.5,
            cursorStyle: "ns-resize",
            actionHandler: (eventData, transform, x, y) => {
              const target = transform.target;
              const canvas = target.canvas;
              const local = target.toLocalPoint(
                new fabric.Point(x, y),
                "center",
                "center"
              );

              const newHeight = local.y + target.height / 2;
              const dy = (newHeight - target.height) / 2;
              target.top += dy;

              updateSize(target, target.width, newHeight);
              canvas.requestRenderAll();
              return true;
            },
          });

          // ðŸ”¹å·¦ä¸­ï¼ˆmlï¼‰
          this.controls.ml = new fabric.Control({
            x: -0.5,
            y: 0,
            cursorStyle: "ew-resize",
            actionHandler: (eventData, transform, x, y) => {
              const target = transform.target;
              const canvas = target.canvas;
              const local = target.toLocalPoint(
                new fabric.Point(x, y),
                "center",
                "center"
              );

              const newWidth = target.width - local.x * 2; // å› ä¸ºæ˜¯ä»Žå·¦å¾€å³æŽ¨
              const dx = (target.width - newWidth) / 2;
              target.left += dx;

              updateSize(target, newWidth, target.height);
              canvas.requestRenderAll();
              return true;
            },
          });

          // ðŸ”¹å³ä¸­ï¼ˆmrï¼‰
          this.controls.mr = new fabric.Control({
            x: 0.5,
            y: 0,
            cursorStyle: "ew-resize",
            actionHandler: (eventData, transform, x, y) => {
              const target = transform.target;
              const canvas = target.canvas;
              const local = target.toLocalPoint(
                new fabric.Point(x, y),
                "center",
                "center"
              );

              const newWidth = local.x + target.width / 2;
              const dx = (newWidth - target.width) / 2;
              target.left += dx;

              updateSize(target, newWidth, target.height);
              canvas.requestRenderAll();
              return true;
            },
          });
        },
      });

      fabric.CustomRect = CustomRect;

      fabric.CustomRect.fromObject = (options, callback) => {
        const { radius } = options;
        return callback(new fabric.CustomRect(radius, options));
      };

      const canvas = new fabric.Canvas("canvas", { width: 800, height: 800 });

      // ä½¿ç”¨
      const rect = new fabric.CustomRect({
        left: 20,
        top: 20,
        width: 100,
        height: 50,
        fill: "lightblue",
        stroke: "black",
        strokeWidth: 1,
        radius: [0, 5, 10, 15], // CSS border-radius é£Žæ ¼
      });
      canvas.add(rect);

      const rect2 = new fabric.CustomRect({
        left: 150,
        top: 20,
        width: 150,
        height: 50,
        fill: "lightgreen",
        stroke: "black",
        strokeWidth: 1,
        radius: [0, 0, 10, 10], // CSS border-radius é£Žæ ¼
      });

      canvas.add(rect2);

      const rect3 = new fabric.CustomRect({
        left: 320,
        top: 20,
        width: 50,
        height: 150,
        fill: "lightgreen",
        stroke: "black",
        strokeWidth: 1,
        radius: [10, 0, 0, 10], // CSS border-radius é£Žæ ¼
      });
      canvas.add(rect3);

      const rect4 = new fabric.CustomRect({
        left: 20,
        top: 120,
        width: 200,
        height: 80,
        fill: "lightgreen",
        stroke: "black",
        strokeWidth: 1,
        maxRadius: true,
      });
      canvas.add(rect4);
    </script>
  </body>
</html>
