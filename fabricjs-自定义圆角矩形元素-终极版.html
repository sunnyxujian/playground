<!DOCTYPE html>
<html>
  <head>
    <title>fabricjs自定义圆角矩形元素（优化版）</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
    <style>
      canvas {
        border: 1px solid #ccc;
      }
    </style>
  </head>
  <body>
    <div id="canvas-container">
      <canvas id="canvas" width="800" height="800"></canvas>
    </div>

    <script>
      // 工具函数类
      class RoundRectUtils {
        static MIN_SIZE = 10;

        // 解析圆角配置
        static parseRadius(radius) {
          let r = [];

          if (typeof radius === "number") {
            r = [
              [radius, radius],
              [radius, radius],
              [radius, radius],
              [radius, radius],
            ];
          } else if (Array.isArray(radius)) {
            if (radius.length === 2) {
              r = [
                [radius[0], radius[0]],
                [radius[1], radius[1]],
                [radius[0], radius[0]],
                [radius[1], radius[1]],
              ];
            } else if (radius.length === 3) {
              r = [
                [radius[0], radius[0]],
                [radius[1], radius[1]],
                [radius[2], radius[2]],
                [radius[1], radius[1]],
              ];
            } else if (radius.length === 4) {
              r = [
                [radius[0], radius[0]],
                [radius[1], radius[1]],
                [radius[2], radius[2]],
                [radius[3], radius[3]],
              ];
            } else if (Array.isArray(radius[0])) {
              r = radius;
            }
          }

          if (!r.length) {
            r = [
              [0, 0],
              [0, 0],
              [0, 0],
              [0, 0],
            ];
          }

          return r;
        }

        // 计算最小尺寸约束
        static calculateMinConstraints(target, newW, newH) {
          if (target.maxRadius) {
            // 跑道圆模式：根据方向决定约束
            if (newW > newH) {
              // 横向跑道圆：高度为直径
              newH = Math.max(newH, this.MIN_SIZE);
              const radius = newH / 2;
              newW = Math.max(newW, radius * 2);
            } else {
              // 纵向跑道圆：宽度为直径
              newW = Math.max(newW, this.MIN_SIZE);
              const radius = newW / 2;
              newH = Math.max(newH, radius * 2);
            }
          } else if (target.radius) {
            // 普通圆角矩形：根据圆角计算最小尺寸
            const maxRx = Math.max(...target.radius.map((r) => r[0]));
            const maxRy = Math.max(...target.radius.map((r) => r[1]));
            newW = Math.max(newW, maxRx * 2);
            newH = Math.max(newH, maxRy * 2);
          }

          return { width: newW, height: newH };
        }

        // 计算单方向最小约束
        static calculateMinConstraint(target, dimension, value) {
          if (target.maxRadius) {
            if (dimension === "width") {
              if (target.width > target.height) {
                return Math.max(value, target.height);
              } else {
                return Math.max(value, this.MIN_SIZE);
              }
            } else {
              if (target.width > target.height) {
                return Math.max(value, this.MIN_SIZE);
              } else {
                return Math.max(value, target.width);
              }
            }
          } else if (target.radius) {
            const [tl, tr, br, bl] = target.radius;
            if (dimension === "width") {
              const topSum = tl[0] + tr[0];
              const bottomSum = bl[0] + br[0];
              return Math.max(value, Math.max(topSum, bottomSum));
            } else {
              const leftSum = tl[1] + bl[1];
              const rightSum = tr[1] + br[1];
              return Math.max(value, Math.max(leftSum, rightSum));
            }
          }
          return Math.max(value, 1);
        }

        // 更新跑道圆半径
        static updateMaxRadiusRadius(target) {
          if (target.maxRadius) {
            const radius = Math.min(target.width, target.height) / 2;
            target.radius = [
              [radius, radius],
              [radius, radius],
              [radius, radius],
              [radius, radius],
            ];
          }
        }
      }

      // 控制点处理器类
      class ControlHandlers {
        static createResizeHandler(updateFunction) {
          return (eventData, transform, x, y) => {
            const target = transform.target;
            const canvas = target.canvas;
            const local = target.toLocalPoint(
              new fabric.Point(x, y),
              "center",
              "center"
            );

            const result = updateFunction(target, local);
            if (result) {
              target.setCoords();
              canvas.requestRenderAll();
            }
            return result;
          };
        }

        // 右下角控制点
        static bottomRight(target, local) {
          let newW = local.x + target.width / 2;
          let newH = local.y + target.height / 2;

          const constraints = RoundRectUtils.calculateMinConstraints(
            target,
            newW,
            newH
          );
          newW = constraints.width;
          newH = constraints.height;

          target.set({
            width: newW,
            height: newH,
            scaleX: 1,
            scaleY: 1,
          });

          RoundRectUtils.updateMaxRadiusRadius(target);
          return true;
        }

        // 右边控制点
        static right(target, local) {
          let newW = local.x + target.width / 2;
          newW = RoundRectUtils.calculateMinConstraint(target, "width", newW);

          target.set({ width: newW, scaleX: 1 });
          return true;
        }

        // 左边控制点
        static left(target, local) {
          let newW = target.width / 2 - local.x;
          newW = RoundRectUtils.calculateMinConstraint(target, "width", newW);

          const deltaW = newW - target.width;

          // 计算旋转后的偏移量
          const angle = (target.angle * Math.PI) / 180;
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);

          // 计算在旋转坐标系中的偏移
          const offsetX = -deltaW * cos;
          const offsetY = -deltaW * sin;

          target.set({
            width: newW,
            left: target.left + offsetX,
            top: target.top + offsetY,
            scaleX: 1,
          });
          return true;
        }

        // 上边控制点
        static top(target, local) {
          let newH = target.height / 2 - local.y;
          newH = RoundRectUtils.calculateMinConstraint(target, "height", newH);

          const deltaH = newH - target.height;

          // 计算旋转后的偏移量
          const angle = (target.angle * Math.PI) / 180;
          const cos = Math.cos(angle);
          const sin = Math.sin(angle);

          // 上边控制点：高度变化时，需要考虑旋转后的Y轴方向
          // 在旋转坐标系中，Y轴的变化需要投影到实际的X和Y坐标
          const offsetX = deltaH * sin; // 修正：应该是正号
          const offsetY = -deltaH * cos; // 修正：Y方向偏移

          target.set({
            height: newH,
            left: target.left + offsetX,
            top: target.top + offsetY,
            scaleY: 1,
          });
          return true;
        }

        // 下边控制点
        static bottom(target, local) {
          let newH = local.y + target.height / 2;
          newH = RoundRectUtils.calculateMinConstraint(target, "height", newH);

          target.set({ height: newH, scaleY: 1 });
          return true;
        }
      }

      // 渲染器类
      class RoundRectRenderer {
        static renderMaxRadius(ctx, w, h, x, y) {
          // 根据宽高比例决定横向或纵向跑道圆
          if (w > h) {
            // 横向跑道圆：高度为直径
            const r = h / 2;
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
          } else {
            // 纵向跑道圆：宽度为直径
            const r = w / 2;
            ctx.moveTo(x + r, y);
            ctx.lineTo(x + w - r, y);
            ctx.arcTo(x + w, y, x + w, y + h, r);
            ctx.arcTo(x + w, y + h, x, y + h, r);
            ctx.arcTo(x, y + h, x, y, r);
            ctx.arcTo(x, y, x + w, y, r);
          }
        }

        static renderCustomRadius(ctx, w, h, x, y, radius) {
          const [tl, tr, br, bl] = radius;
          ctx.moveTo(x + tl[0], y);
          ctx.lineTo(x + w - tr[0], y);
          ctx.quadraticCurveTo(x + w, y, x + w, y + tr[1]);
          ctx.lineTo(x + w, y + h - br[1]);
          ctx.quadraticCurveTo(x + w, y + h, x + w - br[0], y + h);
          ctx.lineTo(x + bl[0], y + h);
          ctx.quadraticCurveTo(x, y + h, x, y + h - bl[1]);
          ctx.lineTo(x, y + tl[1]);
          ctx.quadraticCurveTo(x, y, x + tl[0], y);
        }
      }

      // 主类
      const RoundRect = fabric.util.createClass(fabric.Rect, {
        type: "round-rect",
        minSize: RoundRectUtils.MIN_SIZE,

        initialize: function (options) {
          options || (options = {});
          this.callSuper("initialize", options);

          if (options.maxRadius) {
            this.maxRadius = true;
            this.width = Math.max(this.width, this.minSize);
            this.height = Math.max(this.height, this.minSize);
            const r = Math.min(this.width, this.height) / 2 + 10;
            this.radius = [
              [r, r],
              [r, r],
              [r, r],
              [r, r],
            ];
          } else {
            this.maxRadius = false;
            this.radius = RoundRectUtils.parseRadius(options.radius || 0);
          }

          this.set({
            lockScalingX: true,
            lockScalingY: true,
            objectCaching: false,
          });

          this._initCustomControls();
        },

        _render: function (ctx) {
          const w = Math.max(this.width, this.minSize);
          const h = Math.max(this.height, this.minSize);
          const x = -w / 2;
          const y = -h / 2;

          ctx.beginPath();

          if (this.maxRadius) {
            RoundRectRenderer.renderMaxRadius(ctx, w, h, x, y);
          } else {
            RoundRectRenderer.renderCustomRadius(ctx, w, h, x, y, this.radius);
          }

          ctx.closePath();
          this._renderFill(ctx);
          this._renderStroke(ctx);
        },

        _initCustomControls: function () {
          // 右下角
          this.controls.br = new fabric.Control({
            x: 0.5,
            y: 0.5,
            cursorStyle: "nwse-resize",
            actionHandler: ControlHandlers.createResizeHandler(
              ControlHandlers.bottomRight
            ),
          });

          // 右边
          this.controls.mr = new fabric.Control({
            x: 0.5,
            y: 0,
            cursorStyle: "ew-resize",
            actionHandler: ControlHandlers.createResizeHandler(
              ControlHandlers.right
            ),
          });

          // 左边
          this.controls.ml = new fabric.Control({
            x: -0.5,
            y: 0,
            cursorStyle: "ew-resize",
            actionHandler: ControlHandlers.createResizeHandler(
              ControlHandlers.left
            ),
          });

          // 上边
          this.controls.mt = new fabric.Control({
            x: 0,
            y: -0.5,
            cursorStyle: "ns-resize",
            actionHandler: ControlHandlers.createResizeHandler(
              ControlHandlers.top
            ),
          });

          // 下边
          this.controls.mb = new fabric.Control({
            x: 0,
            y: 0.5,
            cursorStyle: "ns-resize",
            actionHandler: ControlHandlers.createResizeHandler(
              ControlHandlers.bottom
            ),
          });
        },
      });

      fabric.RoundRect = RoundRect;
      fabric.RoundRect.fromObject = (options, callback) => {
        const { radius } = options;
        return callback(new fabric.RoundRect(radius, options));
      };

      const canvas = new fabric.Canvas("canvas", { width: 800, height: 800 });

      // 测试用例
      const rect = new fabric.RoundRect({
        left: 20,
        top: 20,
        width: 100,
        height: 50,
        fill: "lightblue",
        stroke: "black",
        strokeWidth: 1,
        radius: [0, 5, 10, 15],
      });
      canvas.add(rect);

      const rect2 = new fabric.RoundRect({
        left: 150,
        top: 20,
        width: 150,
        height: 50,
        fill: "lightgreen",
        stroke: "black",
        strokeWidth: 1,
        radius: [0, 0, 10, 10],
      });
      canvas.add(rect2);

      const rect3 = new fabric.RoundRect({
        left: 320,
        top: 20,
        width: 50,
        height: 150,
        fill: "lightyellow",
        stroke: "black",
        strokeWidth: 1,
        radius: [10, 0, 0, 10],
      });
      canvas.add(rect3);

      const rect4 = new fabric.RoundRect({
        left: 20,
        top: 120,
        width: 200,
        height: 80,
        fill: "lightpink",
        stroke: "black",
        strokeWidth: 1,
        maxRadius: true,
      });
      canvas.add(rect4);

      // 添加一个旋转的测试用例
      const rect5 = new fabric.RoundRect({
        left: 300,
        top: 120,
        width: 100,
        height: 60,
        fill: "lightcoral",
        stroke: "black",
        strokeWidth: 1,
        radius: [10, 10, 10, 10],
        angle: 45, // 旋转45度
      });
      canvas.add(rect5);
    </script>
  </body>
</html>
